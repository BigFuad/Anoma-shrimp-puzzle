<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shrimp Slide Puzzle</title>
<style>
  :root{
    --gap: 6px;
    --tile-radius: 12px;
    --shadow: 0 6px 16px rgba(0,0,0,.15);
    --accent: #ff6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 800px at 70% -10%, #ffecec, #fff);
    color:#222;
    display:flex;
    min-height:100vh;
    align-items:center;
    justify-content:center;
    padding:24px;
  }
  .app{
    width:min(96vw, 720px);
  }
  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:14px;
    flex-wrap:wrap;
  }
  h1{
    font-size:1.1rem;
    margin:0;
    letter-spacing:.3px;
    font-weight:700;
  }
  .stats{
    display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    font-size:.95rem;
  }
  .pill{
    background:#fff;
    border:1px solid #eee;
    padding:8px 10px;
    border-radius:999px;
    box-shadow: var(--shadow);
  }
  .controls{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  button, select, input[type="text"]{
    border-radius:999px;
    border:1px solid #ddd;
    padding:10px 14px;
    background:#fff;
    cursor:pointer;
    font-size:.95rem;
    box-shadow: var(--shadow);
  }
  button:active{ transform: translateY(1px) }
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:transparent;
  }
  .board-wrap{
    background:#fff;
    padding:var(--gap);
    border-radius:16px;
    box-shadow: var(--shadow);
  }
  .board{
    position:relative;
    width:100%;
    aspect-ratio:1/1; /* keeps it perfectly square on mobile */
    touch-action:none; /* we manage swipe ourselves */
    border-radius:12px;
    background:
      repeating-conic-gradient(from 45deg, #fafafa 0 25%, #f5f5f5 0 50%) 0 / 24px 24px;
    overflow:hidden;
  }
  .tile{
    position:absolute;
    top:0; left:0;
    width:0; height:0; /* sized dynamically */
    background-repeat:no-repeat;
    border-radius:var(--tile-radius);
    box-shadow: var(--shadow);
    transition: transform .15s ease;
    will-change: transform;
    user-select:none;
    -webkit-user-drag:none;
  }
  .tile:after{ /* subtle overlay for contrast */
    content:"";
    position:absolute; inset:0;
    border-radius:inherit;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
  }
  .hidden{ display:none }

  .footnote{
    margin-top:10px;
    font-size:.85rem;
    color:#666;
    text-align:center;
  }

  /* Small helper toast */
  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:#111; color:#fff; padding:10px 14px; border-radius:999px;
    font-size:.9rem; opacity:0; pointer-events:none; transition:opacity .2s ease, transform .2s ease;
  }
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(-4px) }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>üç§ Shrimp Slide Puzzle</h1>
      <div class="stats">
        <div class="pill">Moves: <strong id="moves">0</strong></div>
        <div class="pill">Time: <strong id="time">00:00</strong></div>
      </div>
      <div class="controls">
        <select id="size">
          <option value="3">3 √ó 3</option>
          <option value="4" selected>4 √ó 4</option>
          <option value="5">5 √ó 5</option>
        </select>
        <input id="imgPath" type="text" placeholder="image file (default: shrimp.jpg)" style="min-width:210px" />
        <button id="new" class="primary">New Game</button>
      </div>
    </header>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Sliding puzzle board"></div>
    </div>

    <div class="footnote">
      Put your shrimp picture in the <em>same folder</em> as this file and name it <code>shrimp.jpg</code>
      (or type a different filename above). Swipe tiles on mobile or click/tap on desktop.
    </div>
  </div>

  <div id="toast" class="toast">You win! üéâ</div>

<script>
(() => {
  // --- Configuration ---------------------------------------------------------
  const DEFAULT_IMG = 'shrimp.jpg'; // Your shrimp image in same folder as index.html

  // --- State -----------------------------------------------------------------
  let N = 4;                         // grid size
  let tiles = [];                    // 0..N*N-1, where 0 is the empty
  let positions = [];                // index -> {r, c}
  let tileSize = 0;                  // px
  let moves = 0;
  let timerId = null;
  let elapsed = 0;                   // seconds
  let imgSrc = DEFAULT_IMG;

  // --- DOM -------------------------------------------------------------------
  const board = document.getElementById('board');
  const sizeSel = document.getElementById('size');
  const newBtn = document.getElementById('new');
  const movesEl = document.getElementById('moves');
  const timeEl  = document.getElementById('time');
  const imgInput = document.getElementById('imgPath');
  const toast = document.getElementById('toast');

  // --- Helpers ---------------------------------------------------------------
  const rcToIndex = (r,c) => r * N + c;
  const indexToRC = i => ({ r: Math.floor(i / N), c: i % N });

  function resetTimer(){
    if (timerId) clearInterval(timerId);
    elapsed = 0;
    timeEl.textContent = "00:00";
  }
  function startTimer(){
    if (timerId) clearInterval(timerId);
    timerId = setInterval(()=>{
      elapsed++;
      const m = String(Math.floor(elapsed/60)).padStart(2,'0');
      const s = String(elapsed%60).padStart(2,'0');
      timeEl.textContent = `${m}:${s}`;
    }, 1000);
  }

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(()=> toast.classList.remove('show'), 1600);
  }

  function isSolved(arr = tiles){
    for(let i=0;i<arr.length-1;i++){
      if(arr[i] !== i+1) return false;
    }
    return arr[arr.length-1] === 0;
  }

  // Fisher-Yates shuffle then fix parity to ensure solvable
  function shuffleSolvable(){
    const arr = [...Array(N*N).keys()].map(x => x+1);
    arr[arr.length-1] = 0;

    // random shuffle
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    // Ensure solvable
    if(!isSolvable(arr)) {
      // swap two non-empty tiles to flip parity
      const i = arr.findIndex(x => x>1);
      const j = arr.findIndex(x => x>1 && x!==arr[i]);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    // Avoid starting solved
    if(isSolved(arr)) return shuffleSolvable();
    return arr;
  }

  function inversionCount(arr){
    const flat = arr.filter(x=>x!==0);
    let inv=0;
    for(let i=0;i<flat.length;i++){
      for(let j=i+1;j<flat.length;j++){
        if(flat[i] > flat[j]) inv++;
      }
    }
    return inv;
  }
  function isSolvable(arr){
    const inv = inversionCount(arr);
    const blankIndex = arr.indexOf(0);
    const {r} = indexToRC(blankIndex);
    const blankRowFromBottom = N - r; // 1-based
    if(N % 2 === 1){
      // odd grid: inversions must be even
      return inv % 2 === 0;
    } else {
      // even grid:
      // solvable if (blank on even row from bottom and inversions odd) OR
      //            (blank on odd row from bottom and inversions even)
      if(blankRowFromBottom % 2 === 0) return inv % 2 === 1;
      return inv % 2 === 0;
    }
  }

  function buildBoard(){
    board.innerHTML = '';
    positions = Array(N*N);
    const frag = document.createDocumentFragment();

    // create tiles (skip empty 0; we render only numbered tiles)
    for(let i=1;i<N*N;i++){
      const div = document.createElement('div');
      div.className = 'tile';
      div.dataset.val = i; // goal value 1..N*N-1
      frag.appendChild(div);
    }
    board.appendChild(frag);
    computeTileSize();
    layoutTiles(true);
    attachEvents();
  }

  function computeTileSize(){
    const w = board.clientWidth - 2; // subtract a pinch to avoid rounding spill
    tileSize = Math.floor((w - (N-1)*0) / N); // no inner gap; outer padding handles spacing
    // size each tile
    document.querySelectorAll('.tile').forEach(t=>{
      t.style.width = tileSize + 'px';
      t.style.height = tileSize + 'px';
      t.style.backgroundImage = `url("${imgSrc}")`;
      t.style.backgroundSize = `${tileSize*N}px ${tileSize*N}px`;
      t.style.backgroundClip = 'padding-box';
    });
  }

  function layoutTiles(instant=false){
    // update positions map
    for(let i=0;i<tiles.length;i++){
      const {r,c} = indexToRC(i);
      positions[i] = {r,c};
    }
    // position each visual tile according to its current index
    const els = document.querySelectorAll('.tile');
    els.forEach(el=>{
      const val = Number(el.dataset.val);
      const index = tiles.indexOf(val);
      const {r,c} = indexToRC(index);

      // transform to the right cell
      const x = c * tileSize;
      const y = r * tileSize;
      if(instant){
        el.style.transition = 'none';
        el.style.transform = `translate(${x}px, ${y}px)`;
        // force reflow then re-enable transition
        // eslint-disable-next-line no-unused-expressions
        el.offsetHeight;
        el.style.transition = '';
      }else{
        el.style.transform = `translate(${x}px, ${y}px)`;
      }

      // background offset should match the tile's GOAL position (val-1)
      const goal = val - 1;
      const gr = Math.floor(goal / N);
      const gc = goal % N;
      el.style.backgroundPosition = `${-gc*tileSize}px ${-gr*tileSize}px`;
    });
  }

  function newGame(){
    N = Number(sizeSel.value);
    imgSrc = (imgInput.value && imgInput.value.trim()) || DEFAULT_IMG;
    tiles = shuffleSolvable(); // length N*N
    moves = 0; movesEl.textContent = '0';
    resetTimer(); startTimer();
    buildBoard();
  }

  function swap(i,j){
    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
  }

  function tryMove(index){
    // move if adjacent to empty or in same row/col with empty (slide chain)
    const emptyIdx = tiles.indexOf(0);
    if(index === emptyIdx) return false;

    const {r: r1, c: c1} = indexToRC(index);
    const {r: r0, c: c0} = indexToRC(emptyIdx);

    if(r1 === r0){
      // same row: slide horizontally if path clear
      const dir = c0 > c1 ? 1 : -1;
      for(let c = c1 + dir; c !== c0; c += dir){
        if(tiles[rcToIndex(r1,c)] === 0) return false; // shouldn't happen
      }
      // slide tiles towards empty
      for(let c = c0 - dir; c !== c1 - dir; c -= dir){
        const from = rcToIndex(r1,c);
        const to   = rcToIndex(r1,c+dir);
        swap(from,to);
      }
      return true;
    }
    if(c1 === c0){
      // same column: slide vertically if path clear
      const dir = r0 > r1 ? 1 : -1;
      for(let r = r1 + dir; r !== r0; r += dir){
        if(tiles[rcToIndex(r,c1)] === 0) return false;
      }
      for(let r = r0 - dir; r !== r1 - dir; r -= dir){
        const from = rcToIndex(r,c1);
        const to   = rcToIndex(r+dir,c1);
        swap(from,to);
      }
      return true;
    }

    // else check simple adjacency
    const manhattan = Math.abs(r1-r0) + Math.abs(c1-c0);
    if(manhattan === 1){
      swap(index, emptyIdx);
      return true;
    }
    return false;
  }

  function onWin(){
    clearInterval(timerId);
    showToast(`You win! ${moves} moves in ${timeEl.textContent}`);
  }

  // --- Input handling (mouse + touch/swipe) ---------------------------------
  function attachEvents(){
    // Click/tap
    board.addEventListener('click', (e)=>{
      const tileEl = e.target.closest('.tile');
      if(!tileEl) return;
      const val = Number(tileEl.dataset.val);
      const idx = tiles.indexOf(val);
      const moved = tryMove(idx);
      if(moved){
        moves++; movesEl.textContent = String(moves);
        layoutTiles();
        if(isSolved()) onWin();
      }
    }, {passive:true});

    // Touch swipe on a tile:
    let startX=0, startY=0, touchTargetVal=null, tracking=false;

    board.addEventListener('touchstart', (e)=>{
      const t = e.target.closest('.tile');
      if(!t) return;
      const touch = e.changedTouches[0];
      startX = touch.clientX; startY = touch.clientY;
      touchTargetVal = Number(t.dataset.val);
      tracking = true;
    }, {passive:true});

    board.addEventListener('touchend', (e)=>{
      if(!tracking) return;
      tracking = false;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - startX;
      const dy = touch.clientY - startY;
      const dist = Math.hypot(dx,dy);
      const THRESH = Math.max(24, tileSize*0.12); // adaptive threshold
      if(dist < THRESH){
        // Treat as tap
        const idx = tiles.indexOf(touchTargetVal);
        const moved = tryMove(idx);
        if(moved){
          moves++; movesEl.textContent = String(moves);
          layoutTiles();
          if(isSolved()) onWin();
        }
        return;
      }
      // Determine cardinal direction
      const absX = Math.abs(dx), absY = Math.abs(dy);
      let dir = null; // 'L','R','U','D'
      if(absX > absY) dir = dx < 0 ? 'L' : 'R'; else dir = dy < 0 ? 'U' : 'D';

      // Attempt sliding the swiped tile in that direction *towards the empty cell*
      const tileIdx = tiles.indexOf(touchTargetVal);
      const emptyIdx = tiles.indexOf(0);
      const {r: rt, c: ct} = indexToRC(tileIdx);
      const {r: re, c: ce} = indexToRC(emptyIdx);

      let canSlide = false;
      if(dir==='L' && rt===re && ce < ct) canSlide = true;
      if(dir==='R' && rt===re && ce > ct) canSlide = true;
      if(dir==='U' && ct===ce && re < rt) canSlide = true;
      if(dir==='D' && ct===ce && re > rt) canSlide = true;

      const moved = canSlide ? tryMove(tileIdx) : false;
      if(moved){
        moves++; movesEl.textContent = String(moves);
        layoutTiles();
        if(isSolved()) onWin();
      }
    }, {passive:true});

    // Prevent iOS Safari from "rubber-band" scroll while swiping inside the board
    board.addEventListener('touchmove', (e)=>{ 
      if(e.target.closest('.tile')) e.preventDefault();
    }, {passive:false});

    // Resize handling to keep tiles crisp
    window.addEventListener('resize', ()=>{
      computeTileSize();
      layoutTiles(true);
    });
  }

  // --- Kickoff ---------------------------------------------------------------
  sizeSel.addEventListener('change', newGame);
  imgInput.addEventListener('change', newGame);
  newBtn.addEventListener('click', newGame);

  // First run
  newGame();

})();
</script>
</body>
</html>
