<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Anoma Shrimp Puzzle</title>
<meta name="theme-color" content="#0f2d2a" />
<style>
  :root{
    --bg:#08201d;
    --panel:#0f2d2a;
    --accent:#4de0c7;
    --accent-2:#ffd166;
    --text:#f5f7f7;
    --muted:#b9c5c3;
    --tile:#143c38;
    --gap:6px;
    --radius:12px;
    --shadow:0 8px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Inter,Arial,sans-serif;
    background: radial-gradient(1200px 800px at 20% -10%, #0c3b34, var(--bg));
    color: var(--text);
    display:flex; align-items:center; justify-content:center;
    padding:16px;
  }
  .app{
    width:min(1080px,100%);
    display:grid;
    grid-template-columns: 360px 1fr;
    gap:18px;
  }
  @media (max-width: 950px){
    .app{grid-template-columns:1fr; max-width:680px}
  }
  .panel{
    background:linear-gradient(180deg, #113a34, var(--panel));
    border:1px solid rgba(255,255,255,.06);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:16px 16px 12px;
  }
  h1{
    margin:0 0 10px;
    font-size: clamp(22px, 2.2vw, 28px);
    letter-spacing:.3px;
    display:flex; align-items:center; gap:10px;
  }
  h1 .shrimp{
    width:30px;height:30px;border-radius:6px;
    background:url('assets/shrimp.png') center/cover no-repeat;
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.15);
  }
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .row + .row{margin-top:10px}
  .select{
    display:flex; gap:8px;
    background:#0e2c28; padding:6px; border-radius:999px;
    border:1px solid rgba(255,255,255,.08)
  }
  .chip{
    border:0; padding:8px 12px; border-radius:999px; cursor:pointer;
    color:var(--muted); background:transparent; font-weight:600;
  }
  .chip[aria-pressed="true"]{background:var(--accent); color:#042522}
  .btn{
    border:0; padding:10px 14px; border-radius:10px; cursor:pointer;
    background:var(--accent); color:#03211f; font-weight:700;
    box-shadow:0 6px 18px rgba(77, 224, 199, .25);
  }
  .btn.secondary{ background:#173d38; color:var(--text); border:1px solid rgba(255,255,255,.08); box-shadow:none}
  .btn.warn{ background:#ff6b6b; color:#2b0a0a}
  .btn:disabled{opacity:.6; cursor:not-allowed}
  label.upload{
    display:inline-flex; align-items:center; gap:10px; cursor:pointer; padding:8px 12px;
    background:#123a35; border:1px dashed rgba(255,255,255,.2); border-radius:10px;
    color:var(--muted); font-weight:600;
  }
  input[type=file]{display:none}

  /* board */
  .board-wrap{
    position:relative;
    aspect-ratio:1/1;
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    background:#0b2b28;
    overflow:hidden;
    touch-action:none; /* we implement swipe ourselves */
  }
  .board{
    --n:3;
    --gap:var(--gap);
    position:absolute; inset:10px;
    display:grid;
    grid-template-columns: repeat(var(--n), 1fr);
    grid-template-rows: repeat(var(--n), 1fr);
    gap:var(--gap);
    background: #0d2f2b;
    border-radius:12px;
    padding:var(--gap);
  }
  .tile{
    position:relative;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.08);
    background: var(--tile) center/cover no-repeat;
    transition: transform .12s ease-in-out;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.15), 0 2px 10px rgba(0,0,0,.25);
    display:flex; align-items:end; justify-content:end;
    overflow:hidden;
  }
  .tile:active{transform:scale(.98)}
  .tile button{
    position:absolute; inset:0; border:0; background:transparent; cursor:pointer;
    border-radius:inherit;
  }
  .tile .num{
    margin:6px; padding:2px 7px; font:700 12px/1.3 ui-monospace, SFMono-Regular, Menlo, monospace;
    background:rgba(0,0,0,.45); color:#fff; border-radius:6px; opacity:.9;
  }
  .tile.hidden-nums .num{display:none}
  .hole{visibility:hidden}

  .hud{
    margin-top:12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center
  }
  .stat{padding:8px 12px; border-radius:10px; background:#0f3330; color:var(--text); border:1px solid rgba(255,255,255,.06); font-weight:700}
  .stat small{display:block; font-size:11px; color:var(--muted); font-weight:600}

  .tools{display:flex; flex-wrap:wrap; gap:8px; margin:12px 0}
  details.hint{
    background:#0f3330; border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:8px 10px
  }
  details.hint summary{cursor:pointer; font-weight:700}
  .preview{
    margin-top:8px; border-radius:10px; overflow:hidden; border:1px solid rgba(255,255,255,.08);
    height:140px; background:#0b2b28;
  }
  .preview img{width:100%; height:100%; object-fit:cover}
  .footer{margin-top:10px; color:var(--muted); font-size:13px}
  .link{color:var(--accent-2); text-decoration:none}

  .toast{
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px;
    background:#112f2b; border:1px solid rgba(255,255,255,.08);
    color:var(--text); padding:10px 14px; border-radius:999px; box-shadow:var(--shadow);
    z-index:9; opacity:0; pointer-events:none; transition:opacity .3s, transform .3s;
  }
  .toast.show{opacity:1; transform:translate(-50%, -6px)}
  .sr-only{position:absolute !important; width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</head>
<body>
  <div class="app">
    <section class="panel">
      <h1><span class="shrimp" aria-hidden="true"></span> Anoma Shrimp Puzzle</h1>

      <div class="row" role="group" aria-label="Difficulty">
        <div class="select" id="modeSelect">
          <button class="chip" data-n="3" aria-pressed="true">Easy 3Ã—3</button>
          <button class="chip" data-n="4" aria-pressed="false">Medium 4Ã—4</button>
          <button class="chip" data-n="5" aria-pressed="false">Hard 5Ã—5</button>
        </div>
        <button id="shuffleBtn" class="btn">Shuffle</button>
        <button id="pauseBtn" class="btn secondary" aria-pressed="false">Pause</button>
        <button id="undoBtn" class="btn secondary" disabled>Undo</button>
      </div>

      <div class="row">
        <label class="upload">
          <input type="file" id="imgInput" accept="image/*">
          Use my own image
        </label>
        <button id="toggleNums" class="btn secondary" aria-pressed="false" title="Show/Hide numbers">Show numbers</button>
        <button id="muteBtn" class="btn secondary" aria-pressed="false" title="Toggle sound">ðŸ”Š Sound</button>
      </div>

      <div class="board-wrap" id="boardWrap" aria-label="Sliding puzzle board">
        <div class="board" id="board" aria-live="polite"></div>
        <div class="sr-only" id="live">Ready</div>
      </div>

      <div class="hud">
        <div class="stat"><small>Moves</small><span id="moves">0</span></div>
        <div class="stat"><small>Time</small><span id="time">00:00</span></div>
        <div class="stat"><small>Best</small><span id="best">â€”</span></div>
      </div>

      <div class="tools">
        <details class="hint">
          <summary>Hint / Preview</summary>
          <div class="preview"><img id="previewImg" src="assets/shrimp.png" alt="Preview of full image"></div>
          <p class="footer">Tip: press <kbd>H</kbd> to toggle numbers, <kbd>U</kbd> undo, arrows to move.</p>
        </details>
      </div>

      <div class="footer">
        Made for fun. Supports swipe on mobile and arrow keys / WASD on desktop. Progress autosaves per mode.
      </div>
    </section>

    <section class="panel">
      <h2 style="margin:0 0 8px;font-size:18px;color:var(--muted)">How to play</h2>
      <ol style="margin:0 0 12px 18px; line-height:1.5">
        <li>Choose a difficulty and press <b>Shuffle</b>.</li>
        <li>Slide tiles to reassemble the image. The blank space is the hole.</li>
        <li>Use swipe, arrow keys, or click/tap a tile adjacent to the hole.</li>
      </ol>
      <p style="margin:0 0 6px">Extras:</p>
      <ul style="margin:0 0 0 18px; line-height:1.5">
        <li>Pause/Resume, Undo (last 20 moves)</li>
        <li>Move counter & timer; best time stored by mode</li>
        <li>Upload your own picture; show/hide tile numbers</li>
      </ul>
      <p class="footer">Drop your sound files into <code>/sounds</code> with names:
        <code>move.mp3</code>, <code>shuffle.mp3</code>, <code>win.mp3</code>, <code>tick.mp3</code> (optional).
      </p>
    </section>
  </div>

  <!-- Sounds: replace with your files in /sounds -->
  <audio id="sMove" src="sounds/move.mp3" preload="auto"></audio>
  <audio id="sShuffle" src="sounds/shuffle.mp3" preload="auto"></audio>
  <audio id="sWin" src="sounds/win.mp3" preload="auto"></audio>
  <audio id="sTick" src="sounds/tick.mp3" preload="auto"></audio>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const formatTime = s => {
    const m = Math.floor(s/60), r = s%60;
    return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
  };
  const storageKey = (n)=>`shrimpPuzzle_${n}`;
  const bestKey = (n)=>`shrimpPuzzle_best_${n}`;

  // ---------- State ----------
  let N = 3; // grid size
  let order = []; // tiles order (0..N*N-1), last is hole
  let hole = 0; // index of the hole in order (position)
  let moves = 0;
  let seconds = 0;
  let timerId = null;
  let paused = false;
  let imgURL = 'assets/shrimp.png';
  let showNums = false;
  const undoStack = []; // store tile indexes to undo (max 20)

  // ---------- Elements ----------
  const board = $('#board');
  const boardWrap = $('#boardWrap');
  const movesEl = $('#moves'), timeEl = $('#time'), bestEl = $('#best'), live = $('#live');
  const modeSelect = $('#modeSelect');
  const shuffleBtn = $('#shuffleBtn');
  const pauseBtn = $('#pauseBtn');
  const undoBtn = $('#undoBtn');
  const imgInput = $('#imgInput');
  const toggleNumsBtn = $('#toggleNums');
  const muteBtn = $('#muteBtn');
  const previewImg = $('#previewImg');

  const sMove = $('#sMove'), sShuffle = $('#sShuffle'), sWin = $('#sWin'), sTick = $('#sTick');

  // ---------- Sounds ----------
  let muted = localStorage.getItem('shrimpPuzzle_muted') === '1';
  muteBtn.setAttribute('aria-pressed', String(!muted));
  muteBtn.textContent = muted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Sound';
  const play = (audio, vol = 1.0) => {
    if (muted || !audio) return;
    audio.currentTime = 0;
    audio.volume = vol;
    audio.play().catch(()=>{});
  };
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    localStorage.setItem('shrimpPuzzle_muted', muted?'1':'0');
    muteBtn.textContent = muted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Sound';
    muteBtn.setAttribute('aria-pressed', String(!muted));
    toast(muted ? 'Sound off' : 'Sound on');
  });

  // ---------- Toast ----------
  const toastEl = document.createElement('div');
  toastEl.className = 'toast'; document.body.appendChild(toastEl);
  let toastTimer;
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 1600);
  }

  // ---------- Board rendering ----------
  function buildBoard(){
    board.style.setProperty('--n', N);
    board.innerHTML = '';
    const total = N*N;
    for (let i=0;i<total;i++){
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.index = i; // correct index
      // background slice
      const row = Math.floor(i / N);
      const col = i % N;
      tile.style.backgroundImage = `url('${imgURL}')`;
      tile.style.backgroundSize = `${N*100}% ${N*100}%`;
      tile.style.backgroundPosition = `${(col/(N-1))*100}% ${(row/(N-1))*100}%`;

      const btn = document.createElement('button');
      btn.setAttribute('aria-label', `Tile ${i+1}`);
      btn.addEventListener('click', ()=> tryMoveByTile(btn.parentElement));
      tile.appendChild(btn);

      const badge = document.createElement('div');
      badge.className = 'num';
      badge.textContent = i+1;
      tile.appendChild(badge);

      board.appendChild(tile);
    }
    // add hole class to last tile
    getTileByCorrectIndex(total-1).classList.add('hole');
    applyOrderToDOM();
    setNumbersVisibility();
  }
  function getTileByCorrectIndex(idx){
    return board.querySelector(`.tile[data-index="${idx}"]`);
  }
  function applyOrderToDOM(){
    // set order via CSS grid
    order.forEach((correctIndex, pos) => {
      const tile = getTileByCorrectIndex(correctIndex);
      tile.style.order = pos;
    });
  }

  // ---------- Game logic ----------
  function solved(){
    for (let i=0; i<order.length; i++) if (order[i] !== i) return false;
    return true;
  }
  function updateHUD(){
    movesEl.textContent = moves;
    timeEl.textContent = formatTime(seconds);
  }
  function startTimer(){
    if (timerId) return;
    timerId = setInterval(() => {
      if (!paused) {
        seconds++;
        updateHUD();
        if (seconds % 1 === 0) play(sTick, .15);
      }
    }, 1000);
  }
  function stopTimer(){
    clearInterval(timerId); timerId = null;
  }
  function resetStats(){
    moves = 0; seconds = 0; paused = false;
    pauseBtn.setAttribute('aria-pressed','false');
    pauseBtn.textContent = 'Pause';
    undoStack.length = 0; undoBtn.disabled = true;
    updateHUD();
  }

  function setNumbersVisibility(){
    $$('.tile').forEach(t => {
      if (showNums) t.classList.remove('hidden-nums'); else t.classList.add('hidden-nums');
    });
    toggleNumsBtn.textContent = showNums ? 'Hide numbers' : 'Show numbers';
    toggleNumsBtn.setAttribute('aria-pressed', String(showNums));
  }

  function initSolvedOrder(){
    order = Array.from({length:N*N}, (_,i)=>i);
    hole = order.length - 1;
  }

  function shuffle(safeMoves = 200){
    // do a random walk from solved state so it remains solvable
    play(sShuffle, .8);
    initSolvedOrder();
    let lastDir = -1;
    for (let k=0;k<safeMoves;k++){
      const opts = validMovesFromHole().filter(d=>Math.abs(d-lastDir)!==2); // avoid back/forth
      const dir = opts[Math.floor(Math.random()*opts.length)];
      slide(dir, false); // silent move
      lastDir = dir;
    }
    moves = 0; seconds = 0; paused = false; undoStack.length = 0; undoBtn.disabled = true;
    startTimer(); updateHUD(); saveState();
    live.textContent = 'Shuffled. Game started.';
  }

  function posToRC(pos){ return [Math.floor(pos/N), pos%N]; }
  function rcToPos(r,c){ return r*N + c; }

  // Return possible directions relative to hole: 0=up,1=right,2=down,3=left (tile moving into hole)
  function validMovesFromHole(){
    const [r,c] = posToRC(hole);
    const dirs = [];
    if (r>0) dirs.push(0);
    if (c<N-1) dirs.push(1);
    if (r<N-1) dirs.push(2);
    if (c>0) dirs.push(3);
    return dirs;
  }
  // Slide tile into hole according to direction, optionally record history and play sound
  function slide(dir, withFX=true){
    const [r,c] = posToRC(hole);
    let fromPos;
    if (dir===0) fromPos = rcToPos(r-1,c);
    else if (dir===1) fromPos = rcToPos(r,c+1);
    else if (dir===2) fromPos = rcToPos(r+1,c);
    else if (dir===3) fromPos = rcToPos(r,c-1);
    else return false;

    // swap order[fromPos] with order[hole]
    const tileIndex = order[fromPos];
    [order[fromPos], order[hole]] = [order[hole], order[fromPos]];
    hole = fromPos;
    applyOrderToDOM();
    if (withFX) {
      moves++; updateHUD();
      play(sMove, .6);
      if (navigator.vibrate) navigator.vibrate(8);
      undoStack.push((dir+2)%4); // inverse direction
      if (undoStack.length>20) undoStack.shift();
      undoBtn.disabled = undoStack.length===0;
      saveState();
      if (solved()){
        stopTimer();
        const best = loadBest(N);
        if (!best || seconds < best) saveBest(N, seconds);
        renderBest();
        play(sWin, .9);
        toast(`Solved in ${moves} moves â€¢ ${formatTime(seconds)}`);
        live.textContent = 'Puzzle solved. Congratulations!';
      }
    }
    return true;
  }

  function tryMoveByTile(tileEl){
    const correctIndex = Number(tileEl.dataset.index);
    const pos = order.indexOf(correctIndex);
    const [tr,tc] = posToRC(pos);
    const [hr,hc] = posToRC(hole);
    // must be adjacent
    const dr = tr-hr, dc = tc-hc;
    let dir = null;
    if (dr===-1 && dc===0) dir=2; // tile above hole -> move down
    else if (dr===1 && dc===0) dir=0; // below -> up
    else if (dc===-1 && dr===0) dir=1; // left -> right
    else if (dc===1 && dr===0) dir=3; // right -> left
    if (dir!==null) slide(dir, true);
  }

  // ---------- Input: keyboard ----------
  window.addEventListener('keydown', (e)=>{
    if (paused) return;
    let dir = null;
    if (e.key==='ArrowUp' || e.key==='w' || e.key==='W') dir = 2; // move tile down into hole
    else if (e.key==='ArrowRight' || e.key==='d' || e.key==='D') dir = 3;
    else if (e.key==='ArrowDown' || e.key==='s' || e.key==='S') dir = 0;
    else if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') dir = 1;
    else if (e.key==='h' || e.key==='H'){ showNums=!showNums; setNumbersVisibility(); return;}
    else if (e.key==='u' || e.key==='U'){ undoLast(); return;}
    else return;
    e.preventDefault();
    const ok = validMovesFromHole().includes(dir);
    if (ok) slide(dir, true);
  });

  // ---------- Input: swipe (touch) ----------
  let touchStart = null;
  boardWrap.addEventListener('touchstart', e=>{
    if (paused) return;
    const t = e.changedTouches[0];
    touchStart = {x:t.clientX, y:t.clientY, time: e.timeStamp};
  }, {passive:true});
  boardWrap.addEventListener('touchend', e=>{
    if (paused || !touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const dt = e.timeStamp - touchStart.time;
    if (Math.max(adx,ady) < 18 || dt>500) return; // must be a quick swipe
    let dir = null;
    if (adx>ady) dir = dx>0 ? 3 : 1;   // swipe right -> move left tile into hole
    else dir = dy>0 ? 0 : 2;           // swipe down -> move up tile into hole
    if (validMovesFromHole().includes(dir)) slide(dir, true);
    touchStart = null;
  }, {passive:true});

  // ---------- Buttons ----------
  modeSelect.addEventListener('click', (e)=>{
    const b = e.target.closest('.chip'); if (!b) return;
    const n = Number(b.dataset.n);
    if (n===N) return;
    $$('#modeSelect .chip').forEach(x=>x.setAttribute('aria-pressed','false'));
    b.setAttribute('aria-pressed','true');
    setMode(n, true);
  });

  shuffleBtn.addEventListener('click', ()=> {
    shuffle(120 + N*120);
  });

  pauseBtn.addEventListener('click', ()=>{
    paused = !paused;
    pauseBtn.setAttribute('aria-pressed', String(paused));
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    live.textContent = paused ? 'Game paused.' : 'Game resumed.';
  });

  undoBtn.addEventListener('click', undoLast);
  function undoLast(){
    if (!undoStack.length || paused) return;
    const invDir = undoStack.pop();
    slide(invDir, false); // silent
    moves = Math.max(0, moves-1);
    updateHUD(); play(sMove, .4);
    undoBtn.disabled = undoStack.length===0;
    saveState();
  }

  imgInput.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    setImage(url);
    previewImg.src = url;
    toast('Image updated');
  });

  toggleNumsBtn.addEventListener('click', ()=>{
    showNums = !showNums;
    setNumbersVisibility();
    localStorage.setItem('shrimpPuzzle_showNums', showNums?'1':'0');
  });

  // ---------- Persistence ----------
  function saveState(){
    const data = {order, hole, moves, seconds, imgURL, showNums};
    localStorage.setItem(storageKey(N), JSON.stringify(data));
  }
  function loadState(n){
    try{
      const json = localStorage.getItem(storageKey(n));
      if (!json) return null;
      return JSON.parse(json);
    }catch{ return null; }
  }
  function saveBest(n, secs){
    localStorage.setItem(bestKey(n), String(secs));
  }
  function loadBest(n){
    const v = localStorage.getItem(bestKey(n));
    return v ? Number(v) : null;
  }
  function renderBest(){
    const best = loadBest(N);
    bestEl.textContent = best ? formatTime(best) : 'â€”';
  }

  // ---------- Public-ish helpers ----------
  function setMode(n, rebuild=false){
    N = n;
    board.setAttribute('aria-label', `Sliding puzzle board ${N} by ${N}`);
    if (rebuild) buildBoard();
    initSolvedOrder();
    applyOrderToDOM();
    resetStats();
    renderBest();
    // try to resume saved state for this mode
    const state = loadState(N);
    if (state && state.order?.length === N*N){
      ({order, hole, moves, seconds, imgURL, showNums} = state);
      applyOrderToDOM();
      setImage(imgURL, false);
      showNums = !!state.showNums;
      setNumbersVisibility();
      updateHUD();
      startTimer();
      toast('Resumed your last game');
    } else {
      stopTimer(); timeEl.textContent='00:00';
    }
  }
  function setImage(url, rebuild=true){
    imgURL = url;
    $$('.tile').forEach(tile=>{
      tile.style.backgroundImage = `url('${imgURL}')`;
    });
    $('.shrimp').style.backgroundImage = `url('${imgURL}')`;
    previewImg.src = imgURL;
    if (rebuild) buildBoard();
    saveState();
  }

  // ---------- Boot ----------
  (function boot(){
    // Restore settings
    showNums = localStorage.getItem('shrimpPuzzle_showNums') === '1';
    setNumbersVisibility();
    setImage(imgURL, false);
    buildBoard();
    setMode(3, false);
    renderBest();
    // Attempt resume current mode if available
    const st = loadState(N);
    if (st && st.order?.length===N*N){
      ({order, hole, moves, seconds, imgURL, showNums} = st);
      setImage(imgURL, false);
      applyOrderToDOM();
      setNumbersVisibility();
      updateHUD();
      startTimer();
    } else {
      initSolvedOrder(); applyOrderToDOM();
    }
  })();

})();
</script>
</body>
</html>
